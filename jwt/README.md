# JWT Algorithm Confusion CTF Challenge

## Описание уязвимости
**JWT Algorithm Confusion** — это уязвимость, возникающая, когда сервер некорректно проверяет алгоритм подписи токена JWT. Злоумышленник может подменить алгоритм в заголовке токена, заставив сервер использовать неверный метод проверки подписи. Это позволяет сгенерировать валидный токен без знания секретного ключа.


### Почему возникает уязвимость?
1. **Доверие к заголовку токена**: Сервер полагается на поле `alg` в заголовке JWT для выбора алгоритма проверки подписи, но не проверяет его корректность.
2. **Использование публичного ключа в HMAC**: 
   - При использовании асимметричного алгоритма (например, RS256) сервер хранит приватный ключ для подписи, а публичный — для проверки.
   - Если злоумышленник подменяет `alg` на HS256 (симметричный алгоритм), а сервер использует публичный ключ RS256 в качестве секрета для HMAC, подпись можно подделать, так как публичный ключ часто доступен.

## Способы защиты
### 1. Явное указание алгоритма на сервере
Нужно явно прописать whitelist для заголовков `alg` в токене. Токены с другими алгоритмами в заголовке считать невалидными.
## Запуск приложения

Для запуска приложения выполните следующие шаги:

1. Склонируйте репозиторий:
   ```bash
   git clone https://github.com/anAwesomeWave/ctf_tasks.git
   cd ctf_tasks/jwt
   ```

2. Запустите приложение через Docker Compose:
   ```bash
   docker-compose up --build
   ```

3. Приложение будет доступно по адресу: [http://localhost:8080](http://localhost:8080)

4. Для остановки приложения выполните:
   ```bash
   docker-compose down -v
   ```

## Конфигурация приложения
Для настройки данного приложения используются переменные окружения, прописываемые в docker-compose файле.
- `CTF_FLAG` - флаг задания.



## Описание уязвимости в данном приложении

В данном приложении уязвимость связана со сменой ассиметричного алгоритма подписи (RS256) на симметричный (HS256).
В ассиметричных алгоритмах подписи приватный ключ используется для подписи токена, а публичный — для проверки подписи.
Публичный ключ, зачастую, может отдаваться наружу пользователям, так как он не считается чувствительной информацией.
Такон ключ может отдаваться через API сервера, быть частью токена, часть SSL-сертииката и тому подобное.


Однако в симметричном алгоритме HS256 существует только 1 ключ для подписи и проверки подписи.
Так как публичный ключ используется для проверки, и он может быть нам известен, можно зашифровать с его помощью токен,
поменять алгоритм шифрования вместе с другими данными, и сервер пропустит такой токен.


## Шаги для получения флага

Для использования уязвимости выполните следующие шаги:

1. идем на эндпоинт `/auth`, изучаем токен и смотрим, что мы можем поменять поле `"user"`. Видим, что токен сохранился в cookie браузера.
2. Переходим на страницу `/public-key`. Копируем публичный ключ.
3. Меняем поле токена, подписываем его публичным ключом
  Поля для токена должны выглядеть примерно так.
   ```json
   {
   "header": {
         "alg": {
            "HS256"
            "typ":"JWT"
            }
         "payload":  {
            "exp": 1741285400
            "user": "admin"
         }
      }
   }

   ```
4. Также можно использовать код attack.go, положив публичный ключ (с \n на конце) в файл pub.txt.
   ```bash
   go run attack.go
   ```
5. Кладем полученный токен в cookie браузера (или в заголовок Authorization или в query ?token=...).
6. Делаем запрос на страницу `/` 

