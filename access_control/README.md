# Access Control CTF Challenge

## Описание уязвимости
В данном CTF-задании используется уязвимость, связанная с некорректной проверкой прав доступа. Для проверки доступа к файлу
приложение использует query-параметр `is_visible`, доступный внешнему пользователю. Вследствие чего, пользователь
может самостоятельно послать http-запрос на нужный эндпоинт с соответствующем query-параметром и получить доступ к ресурсу.

## Способы защиты от уязвимости
1. **Аутентификация и авторизация:** Нельзя завязывать логику футентификации и авторизации на доступные пользователю параметры, которые он может подменить. Так, например, нельзя использовать Http-заголовки (или открытые токены (jwt) без валидации).
2. **Логирование:** Следует логировать попытки доступа. Особенно подозрительные (недействительный jwt-токен).
3. **Тестирование:** Необходимо регулярно тестировать систему (сервис) аутентификации/авторизации.

## Запуск приложения

Для запуска приложения выполните следующие шаги:

1. Склонируйте репозиторий:
   ```bash
   git clone https://github.com/anAwesomeWave/ctf_tasks.git
   cd ctf_tasks/access_control
   ```

2. Запустите приложение через Docker Compose:
   ```bash
   docker-compose up --build
   ```

3. Приложение будет доступно по адресу: [http://localhost:8080](http://localhost:8080)

4. Для остановки приложения выполните:
   ```bash
   docker-compose down -v
   ```

## Конфигурация приложения
В качестве конфиг. файлов выступают файлы из папки `access_control/config/`. Для конфигурирования ctf-задания
использует переменные окружения из файла `access_control/config/.app_env`.
- `ADMIN_LOGIN` - login админа
- `ADMIN_PASSWORD` - password админа
- `CTF_FLAG` - флаг задания. (Используйте не более ~30 символов, чтобы строка поместилась в картинку)
- `JWT_SIGN_KEY` - Секретный ключ для верификации подписи jwt-токенов.
- `MAX_FILE_SIZE_BYTES` - Максимальный размер файла в байтах, который может загрузить пользователь. Стандартно - 3 mb. (Для простоты, в golang можно написать fmt.Println(x << 20), где, x - нужное кол-во мегабайт).
Для более расширенного конфигурирования можно использовать docker-compose файл, указав в нем resources - limits для контейнера.

## Описание уязвимости в данном приложении
Приложение позволяет пользователю получить флаг, отправив запрос на URL с параметрами `userId` и `is_visible`. Например:

```
http://localhost:8080/static/images/{userId}1.jpeg&is_visible=true
```


## Шаги для получения флага
Для того, чтобы получить флаг, вам нужно получить доступ к закрытому от вас ресурсу.

- a) Смотрим на html-код подгруженной страницы. Видим, что запрос идет на ручку `/static/images/default/1.jpeg?is_public=true`,
также посмотрим на другие картинки, которые были подгружены. (Пример:`/static/images/bd4ecc7d-07b4-411f-a7d4-34f21dea885e/1.jpeg?is_public=true`)
Делаем вывод: нам нужны 1. uuid админа (вот эта часть `bd4ecc7d-07b4-411f-a7d4-34f21dea885e`, так как она совпадает для разных картинок от 1 пользователя) 2. параметр is_visible в запросе для доступа к ресурсу)
- b) Видим, что у подгруженных аватарок и картинок в рамках одного блока-поста id пользователя совпадает. Также 
видим то, что аватар админа нам доступен, и в адресе, по которому он берется, также есть id.
- c) Также понимаем, что это единственная картинка админа, значит название файла (предположительно) - 1.jpeg
Итог, делаем запрос к эндпоинту
```bash
wget '/static/images/{AdminId}/1.jpeg?is_public=true'
```

В результате сервер вернет изображение с флагом.